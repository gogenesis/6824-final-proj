// This program generates combination_tests.go. It can be invoked by running "go generate".
//
// Also, because this program is executable, it must be in package main.
// The compiler requires that it be in a folder named main, but
// we don't want to store it in a folder named main, so we tell the compiler to ignore this file
// when building with this second magic comment.
// +build ignore
//

package main

import (
	"fmt"
	"fsraft"
	"os"
	"reflect"
	"runtime"
	"strings"
	"time"
)

type genFileParameters struct {
	fileName                string
	pkg                     string // "package" is a reserved word
	imports                 []string
	headerComment           string
	fileSystemName          string
	testNamesToMethodBodies map[string]string // "Test${fileSystemName}_" is automatically prepended to test names
}

func main() {
	fmt.Println("Generating test files.")
	//First, generate a file with a unit test for memoryFS for every functionality test.
	memoryFSTestGenParams := genFileParameters{
		fileName:                "memoryFS_test.go",
		pkg:                     "memoryFS",
		imports:                 []string{"testing", "fsraft"},
		headerComment:           "// This file contains a unit test for every functionality test (found in filesystem_tests.go).",
		fileSystemName:          "MemoryFS",
		testNamesToMethodBodies: make(map[string]string, 0),
	}

	for _, functionality := range fsraft.FunctionalityTests {
		functionalityName := GetFunctionName(functionality)
		testName := fmt.Sprintf("%v", functionalityName)
		methodBody := fmt.Sprintf("mfs := CreateEmptyMemoryFS()\n        fsraft.%v(t, &mfs)", functionalityName)
		memoryFSTestGenParams.testNamesToMethodBodies[testName] = methodBody
	}

	genTestFile(memoryFSTestGenParams)

	// Then, the file to test the Clerk, which has all combinations of functionality tests and difficulties.
	combinationTestGenParams := genFileParameters{
		fileName: "combination_test.go",
		pkg:      "fsraft",
		imports:  []string{"testing"},
		headerComment: `// This file contains a unit test for every combination of functionality test
// (found in filesystem_tests.go) and difficulty (found in test_setup.go).`,
		fileSystemName:          "Clerk",
		testNamesToMethodBodies: make(map[string]string, 0),
	}

	for _, functionality := range fsraft.FunctionalityTests {
		functionalityName := GetFunctionName(functionality)
		for _, difficulty := range fsraft.Difficulties {
			difficultyName := GetFunctionName(difficulty)

			testName := fmt.Sprintf("%v_%v", functionalityName, difficultyName)
			methodBody := fmt.Sprintf("runFunctionalityTestWithDifficulty(t, %v, %v)", functionalityName, difficultyName)
			combinationTestGenParams.testNamesToMethodBodies[testName] = methodBody
		}
	}

	genTestFile(combinationTestGenParams)
}

func genTestFile(params genFileParameters) {
	fmt.Printf("Generating %v\n", params.fileName)
	genFile, err := os.Create(params.fileName)
	assertNoError(err)
	defer genFile.Close()

	header := fmt.Sprintf(`// Code generated by generate_unit_tests.go. DO NOT EDIT.
%v
// Generated at %v.

package %v

`, params.headerComment, time.Now().Format("Mon Jan 2 3:04:05 PM"), params.pkg)
	genFile.Write([]byte(header))

	for _, importedPackage := range params.imports {
		genFile.Write([]byte(fmt.Sprintf("import \"%v\"\n", importedPackage)))
	}
	if len(params.imports) > 0 {
		genFile.Write([]byte("\n"))
	}

	for testName, methodBody := range params.testNamesToMethodBodies {
		genFile.Write([]byte(fmt.Sprintf(
			`func Test%v_%v(t *testing.T) {
	%v
}

`, params.fileSystemName, testName, methodBody)))
	}

	os.Rename(params.fileName, "../"+params.pkg+"/"+params.fileName)
}

func assertNoError(e error) {
	if e != nil {
		panic(e.Error())
	}
}

// Get the name of a function, not including its package.
func GetFunctionName(i interface{}) string {
	nameWithPackage := runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
	periodIndex := strings.Index(nameWithPackage, ".")
	return nameWithPackage[periodIndex+1:]
}
